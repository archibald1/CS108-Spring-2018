package seminar13.threads;/* ლექციის მაგალითი *//* A simple class that demonstrates using the 'synchronized' keyword so that multiple threads may send it messages. The class stores two ints, a and b; sum() returns their sum, and increment() increments both numbers.  <p> The sum() and incr() methods form a "critical section" -- they can compute the wrong thing if run by multiple threads at the same time. The sum() and increment() methods are declared "synchronized" -- they respect the lock in the receiver object.*/@SuppressWarnings("WeakerAccess")class ThreadUnsafePair {    private int a, b;    public ThreadUnsafePair() {        a = 0;        b = 0;    }    // Returns the sum of a and b. (reader)    // Should always return an even number.    public int sum() {        return (a + b);    }    // Increments both a and b. (writer)    public void increment() {        a++;        b++;    }}/* A simple worker subclass of Thread. In its run(), sends 1000 increment() messages to its ThreadUnsafePair object. (1000 may not be big enough to exhibit the bug on uniprocessor --  hardware more like 1000000 may be required).*/@SuppressWarnings("WeakerAccess")class PairWorker extends Thread {    public final int COUNT = 1000;    private ThreadUnsafePair threadUnsafePair;    // Ctor takes a pointer to the threadUnsafePair we use    public PairWorker(ThreadUnsafePair threadUnsafePair) {        this.threadUnsafePair = threadUnsafePair;    }    // Send many increment() messages to our threadUnsafePair    @Override    public void run() {        for (int i = 0; i < COUNT; ++i) {            threadUnsafePair.increment();        }    }    /*     Test main -- Create a ThreadUnsafePair and 3 workers.     Start the 3 workers -- they do their run() --     and wait for the workers to finish.    */    public static void main(String args[]) {        ThreadUnsafePair threadUnsafePair = new ThreadUnsafePair();        PairWorker w1 = new PairWorker(threadUnsafePair);        PairWorker w2 = new PairWorker(threadUnsafePair);        PairWorker w3 = new PairWorker(threadUnsafePair);        w1.start();        w2.start();        w3.start();        // the 3 workers are running        // all sending messages to the same object        // we block until the workers complete        try {            w1.join();            w2.join();            w3.join();        } catch (InterruptedException ignored) {        }        System.out.println("Final sum:" + threadUnsafePair.sum());    // should be 6000        /*         If sum()/increment() were not synchronized, the result would		 be 6000 in some cases, and other times random values		 like 5979 due to the writer/writer conflicts of multiple		 threads trying to execute increment() on an object at the same time.		*/    }}