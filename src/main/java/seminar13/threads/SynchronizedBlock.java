package seminar13.threads;/* Demonstrates using individual lock objects with the synchronized(lock) {...} form instead of synchronizing methods -- allows finer grain in the locking.*/@SuppressWarnings("WeakerAccess")public class SynchronizedBlock {    // one lock for the fruits    private int apple, banana;    private final Object fruitLock;    // one lock for the numbers    private int[] numbers;    private int numLen;    private final Object numLock;    public SynchronizedBlock() {        apple = 0;        banana = 0;        // allocate an object just to use it as a lock        // (could use a string or some other object just as well)        fruitLock = new Object();        numbers = new int[100];        numLen = 0;        numLock = new Object();    }    public void addFruit() {        synchronized (fruitLock) {            ++apple;            ++banana;        }    }    public int getFruit() {        synchronized (fruitLock) {            return (apple + banana);        }    }    public void pushNum(int num) {        synchronized (numLock) {            numbers[numLen++] = num;        }    }    // Suppose we pop and return num, but if the num is negative return    // its absolute value -- demonstrates holding the lock for the minimum time.    @SuppressWarnings("UnusedReturnValue")    public int popNum() {        int result;        synchronized (numLock) {            result = numbers[numLen--];        }        // do computation not holding the lock if possible        if (result < 0) {            result = -1 * result;        }        return (result);    }    public int getNumSum() {        int sum = 0;        synchronized (numLock) {            for (int i = 0; i < numLen; ++i) {                sum += numbers[i];            }        }        return sum;    }    public void both() {        synchronized (fruitLock) {            synchronized (numLock) {                // some scary operation that uses both fruit and numbers                // note: acquire locks in the same order everwhere to avoid                // deadlock.            }        }    }    public static void main(String[] args) {        SynchronizedBlock threadSafe = new SynchronizedBlock();        // each worker adds 200 fruit        Thread w1 = new MultiWorker(threadSafe);        Thread w2 = new MultiWorker(threadSafe);        Thread w3 = new MultiWorker(threadSafe);        Thread w4 = new MultiWorker(threadSafe);        w1.start();        w2.start();        w3.start();        w4.start();        // the 3 workers are running        // all sending messages to the same object        // we block until the workers complete        try {            w1.join();            w2.join();            w3.join();            w4.join();        } catch (InterruptedException ignored) {        }        // Should print 800 fruits        System.out.println("4 worker x 200 fruit = " + threadSafe.getFruit());        System.out.println(threadSafe.getNumSum());    }}class MultiWorker extends Thread {    @SuppressWarnings("FieldCanBeLocal")    private final int COUNT = 100;    private SynchronizedBlock threadSafeSync;    // Ctor takes a pointer to the threadUnsafePair we use    MultiWorker(SynchronizedBlock safeSync) {        this.threadSafeSync = safeSync;    }    // Send many increment() messages to our threadUnsafePair    @Override    public void run() {        for (int i = 0; i < COUNT; ++i) {            threadSafeSync.addFruit();            threadSafeSync.both();            if (i % 10 == 0) {                threadSafeSync.pushNum(i);                threadSafeSync.pushNum(i);                threadSafeSync.pushNum(i);                threadSafeSync.popNum();                threadSafeSync.popNum();            }            try {                Thread.sleep(5);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}